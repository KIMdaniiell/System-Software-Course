# Операторы управления

+ *Точка с запятой* (**;**)
  + Вы можете разместить **2+** команд в одной строке, разделив их с помощью (**;**)
  + Командная оболочка будет **ожидать завершения** исполнения каждой из команд перед исполнением следующей команды
+ *Амперсанд* (**&**)
  + Если строка команды оканчивается (**&**), командная оболочка не будет ожидать завершения исполнения этой команды.
  + Сразу же после ввода команды будет выведено приглашение командной оболочки, а сама команда будет исполняться в фоновом режиме
  + В момент завершения исполнения команды в фоновом режиме вы получите соответствующее сообщение
+ *Символ доллара со знаком вопроса* (**$?**)
  + Код завершения предыдущей команды сохраняется в переменной командной оболочки (**$?**).
  + > echo $? 
+ *Двойной амперсанд* (**&&**)
  + Вторая команда будет исполняться только в том случае, если исполнение первой команды завершится **успешно** (будет возвращен нулевой код завершения). 
+ *Двойная вертикальная черта* (**||**)
  + Вторая команда исполняется только тогда, когда исполнение первой команды заканчивается **неудачей** (возвращается ненулевой код завершения).
+ *Комбинирование операторов* **&&** и **||**
  + "И" и "ИЛИ" для создания структур условных переходов в рамках строк команд.
  + > rm file1 **&&** echo Команда сработала! **||** echo Исполнение команды завершилось неудачей! 
+ *Знак фунта* (**#**)
  + Все написанное после символа фунта (#) **игнорируется** командной оболочкой - комментарии
+ *Экранирование специальных символов* (**\\**)
  + Символ обратного слэша (**\\**) позволяет использовать управляющие символы без их интерпретации командной оболочкой;
  + Строка команды, заканчивающаяся обратным слэшем, **продолжается** в следующей строке. Командная оболочка не будет интерпретировать символы перехода на новые строки и отложит исполнение операции раскрытия команды и ее исполнение до момента чтения новой строки команды без обратного слэша в конце.
